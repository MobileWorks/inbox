#!/usr/bin/env python
# fill-out the "labels" field for all the imapuids in the db.

import gevent
from gevent import monkey; monkey.patch_all()
from gevent.pool import Pool
from sqlalchemy import func
from inbox.util.itert import chunk
from inbox.mailsync.backends.imap.generic import uidvalidity_cb
from inbox.crispin import connection_pool
from inbox.models.session import session_scope
from inbox.models import Account, Folder
from inbox.models.backends.imap import ImapUid


def gmail_updater():
    with session_scope() as db_session:
        accounts = db_session.query(Account).filter(
            Account.discriminator =='gmailaccount')

    pool = Pool(10)
    failed_accounts_ids = []
    for account in accounts:
        print "Spawning for account: %d" % account.id
        try:
            pool.spawn(account_updater, account)
        except Exception:
            failed_accounts_ids.append(account.id)

    pool.join()
    print failed_accounts_ids


def account_updater(account):
    """Updates all the folders in a given account"""
    with session_scope() as db_session:
        folders = db_session.query(Folder).filter(
            Folder.account_id == account.id)

    for folder in folders:
        # FIXME: I HAVE NO IDEA WHAT I'M DOING - how does this pool thing
        # work? Does it even block?
        pool = connection_pool(account.id)
        greenlet = gevent.spawn(labels_updater, folder, pool)
        # Block, otherwise getting an error about a socket being reused.
        greenlet.join()


def labels_updater(folder, pool):
    """Updates labels for a given folder"""
    UIDS_CHUNK = 1000

    with session_scope() as db_session:
        folder_uids = db_session.query(ImapUid).filter(
            ImapUid.folder_id == folder.id)

        if folder_uids.count() == 0:
            return

        print "refreshing %s" % folder.name
        with pool.get() as crispin_client:
            crispin_client.select_folder(
                folder.name,
                uidvalidity_cb)

            uids_table = {}
            uids = []
            for uid in folder_uids.yield_per(UIDS_CHUNK):
                uids_table[uid.msg_uid] = uid
                uids.append(uid.msg_uid)

            if len(uids) == UIDS_CHUNK:
                flags = crispin_client.flags(uids)
                for uid in flags:
                    if flags[uid].labels is not None and uid in uids_table:
                        uids_table[uid].g_labels = [label for label in flags[uid].labels]

                db_session.commit()
                uids_table = {}
                uids = []


if __name__ == '__main__':
    gmail_updater()
